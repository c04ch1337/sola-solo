//! Malware Sandbox Agent - Autonomous File Analysis with MITRE ATT&CK Integration
//!
//! This agent provides:
//! - VirusTotal API integration for malware scanning
//! - MITRE ATT&CK technique mapping for file behaviors
//! - Playbook-driven analysis workflows
//! - Collaboration with NetworkSecurityAgent for comprehensive threat analysis
//! - Self-improvement through AutonomousEvolutionLoop
//! - PST/email analysis for phishing detection

use anyhow::Result;
use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::path::Path;
use std::sync::Arc;
use tokio::sync::RwLock;
use uuid::Uuid;

pub mod virustotal;
pub use virustotal::*;

/// Errors that can occur in the malware sandbox agent
#[derive(Debug, thiserror::Error)]
pub enum SandboxAgentError {
    #[error("Sandbox error: {0}")]
    Sandbox(#[from] sandbox_manager::SandboxError),

    #[error("Network security error: {0}")]
    NetworkSecurity(#[from] network_security_agent::SecurityAgentError),

    #[error("Analysis failed: {0}")]
    AnalysisFailed(String),

    #[error("VirusTotal API error: {0}")]
    VirusTotal(String),

    #[error("Playbook error: {0}")]
    Playbook(String),

    #[error("IO error: {0}")]
    Io(#[from] std::io::Error),

    #[error("Configuration error: {0}")]
    Configuration(String),
}

/// Malware Sandbox Agent configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MalwareSandboxConfig {
    /// VirusTotal API key
    pub virustotal_api_key: Option<String>,
    /// Enable VirusTotal scanning
    pub virustotal_enabled: bool,
    /// MITRE ATT&CK integration enabled
    pub mitre_enabled: bool,
    /// Autonomous evolution enabled
    pub evolution_enabled: bool,
    /// Evolution trigger threshold (number of analyses)
    pub evolution_threshold: usize,
    /// Accuracy threshold for LTM updates
    pub accuracy_threshold: f32,
    /// Playbook directory
    pub playbook_dir: String,
}

impl Default for MalwareSandboxConfig {
    fn default() -> Self {
        Self {
            virustotal_api_key: std::env::var("VIRUSTOTAL_API_KEY").ok(),
            virustotal_enabled: std::env::var("VIRUSTOTAL_ENABLED")
                .unwrap_or_else(|_| "false".to_string())
                == "true",
            mitre_enabled: std::env::var("MITRE_ATTCK_ENABLED")
                .unwrap_or_else(|_| "true".to_string())
                == "true",
            evolution_enabled: std::env::var("SANDBOX_AGENT_EVOLUTION_ENABLED")
                .unwrap_or_else(|_| "true".to_string())
                == "true",
            evolution_threshold: std::env::var("SANDBOX_AGENT_EVOLUTION_THRESHOLD")
                .ok()
                .and_then(|s| s.parse().ok())
                .unwrap_or(10),
            accuracy_threshold: std::env::var("SANDBOX_AGENT_ACCURACY_THRESHOLD")
                .ok()
                .and_then(|s| s.parse().ok())
                .unwrap_or(0.8),
            playbook_dir: "./playbooks".to_string(),
        }
    }
}

/// Analysis result
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AnalysisResult {
    pub file_id: String,
    pub session_id: String,
    pub analysis_id: Uuid,
    pub started_at: DateTime<Utc>,
    pub completed_at: DateTime<Utc>,
    pub file_info: FileInfo,
    pub virustotal_result: Option<VirusTotalResult>,
    pub mitre_techniques: Vec<MitreTechnique>,
    pub threat_assessment: ThreatAssessment,
    pub recommendations: Vec<String>,
    pub behavioral_indicators: Vec<BehavioralIndicator>,
}

/// File information
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FileInfo {
    pub name: String,
    pub size_bytes: u64,
    pub sha256: String,
    pub md5: String,
    pub mime_type: Option<String>,
}

/// MITRE ATT&CK technique mapped from file analysis
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MitreTechnique {
    pub technique_id: String,
    pub technique_name: String,
    pub tactic: String,
    pub confidence: f32,
    pub evidence: String,
}

/// Threat assessment
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ThreatAssessment {
    pub threat_level: sandbox_manager::ThreatLevel,
    pub risk_score: f32,
    pub is_malicious: bool,
    pub malware_families: Vec<String>,
    pub summary: String,
}

/// Behavioral indicator
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BehavioralIndicator {
    pub indicator_type: String,
    pub description: String,
    pub severity: String,
    pub mitre_technique: Option<String>,
}

/// Playbook for automated analysis
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AnalysisPlaybook {
    pub name: String,
    pub description: String,
    pub steps: Vec<PlaybookStep>,
}

/// Playbook step
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PlaybookStep {
    pub name: String,
    pub action: String,
    pub parameters: HashMap<String, serde_json::Value>,
}

/// Malware Sandbox Agent - Main struct
pub struct MalwareSandboxAgent {
    pub id: Uuid,
    config: MalwareSandboxConfig,
    sandbox_manager: Arc<sandbox_manager::SandboxManager>,
    network_security_agent: Option<Arc<network_security_agent::NetworkSecurityAgent>>,
    virustotal_client: Option<Arc<VirusTotalClient>>,
    llm: Option<Arc<llm_orchestrator::LLMOrchestrator>>,
    analysis_count: Arc<RwLock<usize>>,
    analysis_history: Arc<RwLock<Vec<AnalysisResult>>>,
}

impl MalwareSandboxAgent {
    /// Awaken the Malware Sandbox Agent
    pub async fn awaken(
        sandbox_manager: Arc<sandbox_manager::SandboxManager>,
        config: MalwareSandboxConfig,
    ) -> Result<Self, SandboxAgentError> {
        println!("ðŸ”¬ Malware Sandbox Agent awakening â€” File analysis capabilities online.");

        // Initialize VirusTotal client if enabled
        let virustotal_client = if config.virustotal_enabled {
            if let Some(api_key) = &config.virustotal_api_key {
                println!("  âœ“ VirusTotal integration enabled");
                Some(Arc::new(VirusTotalClient::new(api_key.clone())))
            } else {
                eprintln!("  âš  VirusTotal enabled but no API key provided");
                None
            }
        } else {
            None
        };

        // Initialize NetworkSecurityAgent for collaboration
        let network_security_agent = match network_security_agent::NetworkSecurityAgent::awaken().await {
            Ok(agent) => {
                println!("  âœ“ NetworkSecurityAgent collaboration enabled");
                Some(Arc::new(agent))
            }
            Err(e) => {
                eprintln!("  âš  NetworkSecurityAgent not available: {} - continuing without network analysis", e);
                None
            }
        };

        // Initialize LLM for intelligent analysis
        let llm = match llm_orchestrator::LLMOrchestrator::awaken() {
            Ok(l) => {
                println!("  âœ“ LLM integration enabled for intelligent analysis");
                Some(Arc::new(l))
            }
            Err(e) => {
                eprintln!("  âš  LLM not available: {} - continuing without AI analysis", e);
                None
            }
        };

        Ok(Self {
            id: Uuid::new_v4(),
            config,
            sandbox_manager,
            network_security_agent,
            virustotal_client,
            llm,
            analysis_count: Arc::new(RwLock::new(0)),
            analysis_history: Arc::new(RwLock::new(Vec::new())),
        })
    }

    /// Analyze a file in the sandbox
    pub async fn analyze_file(
        &self,
        session_id: &str,
        file_id: &str,
    ) -> Result<AnalysisResult, SandboxAgentError> {
        let analysis_id = Uuid::new_v4();
        let started_at = Utc::now();

        println!("ðŸ” Starting analysis {} for file {}", analysis_id, file_id);

        // Get file from sandbox
        let files = self.sandbox_manager.list_files(session_id).await?;
        let file = files
            .iter()
            .find(|f| f.id == file_id)
            .ok_or_else(|| {
                SandboxAgentError::AnalysisFailed(format!("File {} not found", file_id))
            })?;

        let file_data = self.sandbox_manager.get_file(session_id, file_id).await?;

        let file_info = FileInfo {
            name: file.original_name.clone(),
            size_bytes: file.size_bytes,
            sha256: file.sha256.clone(),
            md5: file.md5.clone(),
            mime_type: file.mime_type.clone(),
        };

        // Step 1: VirusTotal scan
        let virustotal_result = if let Some(vt_client) = &self.virustotal_client {
            println!("  â†’ Scanning with VirusTotal...");
            match vt_client.scan_file(&file_data, &file.original_name).await {
                Ok(result) => {
                    println!("    âœ“ VirusTotal: {}/{} detections", result.positives, result.total);
                    Some(result)
                }
                Err(e) => {
                    eprintln!("    âš  VirusTotal scan failed: {}", e);
                    None
                }
            }
        } else {
            None
        };

        // Step 2: Static analysis - detect behavioral indicators
        println!("  â†’ Performing static analysis...");
        let behavioral_indicators = self.analyze_file_behavior(&file_data, &file_info).await;

        // Step 3: Map to MITRE ATT&CK techniques
        println!("  â†’ Mapping to MITRE ATT&CK...");
        let mitre_techniques = self.map_to_mitre_techniques(&file_info, &behavioral_indicators, &virustotal_result).await;

        // Step 4: Assess threat level
        let threat_assessment = self.assess_threat(&virustotal_result, &mitre_techniques, &behavioral_indicators).await;

        // Step 5: Generate recommendations
        let recommendations = self.generate_recommendations(&threat_assessment, &mitre_techniques).await;

        // Step 6: Update sandbox with threat level
        self.sandbox_manager
            .update_analysis(session_id, file_id, threat_assessment.threat_level)
            .await?;

        let completed_at = Utc::now();

        let result = AnalysisResult {
            file_id: file_id.to_string(),
            session_id: session_id.to_string(),
            analysis_id,
            started_at,
            completed_at,
            file_info,
            virustotal_result,
            mitre_techniques,
            threat_assessment,
            recommendations,
            behavioral_indicators,
        };

        // Store in history
        {
            let mut history = self.analysis_history.write().await;
            history.push(result.clone());
        }

        // Increment analysis count and check for evolution
        {
            let mut count = self.analysis_count.write().await;
            *count += 1;

            if self.config.evolution_enabled && *count >= self.config.evolution_threshold {
                println!("  â†’ Triggering autonomous evolution cycle...");
                self.trigger_evolution().await;
                *count = 0;
            }
        }

        println!("âœ… Analysis complete: {:?} - {}", result.threat_assessment.threat_level, result.threat_assessment.summary);

        Ok(result)
    }

    /// Analyze file behavior and extract indicators
    async fn analyze_file_behavior(
        &self,
        file_data: &[u8],
        file_info: &FileInfo,
    ) -> Vec<BehavioralIndicator> {
        let mut indicators = Vec::new();

        // Check for suspicious file extensions
        if let Some(ext) = Path::new(&file_info.name).extension() {
            let ext_str = ext.to_string_lossy().to_lowercase();
            if matches!(ext_str.as_str(), "exe" | "dll" | "scr" | "bat" | "cmd" | "ps1" | "vbs" | "js") {
                indicators.push(BehavioralIndicator {
                    indicator_type: "suspicious_extension".to_string(),
                    description: format!("Executable file type: .{}", ext_str),
                    severity: "medium".to_string(),
                    mitre_technique: Some("T1203".to_string()), // Exploitation for Client Execution
                });
            }
        }

        // Check for double extensions (masquerading)
        if file_info.name.matches('.').count() > 1 {
            indicators.push(BehavioralIndicator {
                indicator_type: "double_extension".to_string(),
                description: "File has multiple extensions (possible masquerading)".to_string(),
                severity: "high".to_string(),
                mitre_technique: Some("T1036.007".to_string()), // Masquerading: Double File Extension
            });
        }

        // Check for suspicious strings in file content
        let content_str = String::from_utf8_lossy(file_data);
        
        // Check for PowerShell obfuscation
        if content_str.contains("powershell") || content_str.contains("Invoke-Expression") || content_str.contains("IEX") {
            indicators.push(BehavioralIndicator {
                indicator_type: "powershell_execution".to_string(),
                description: "Contains PowerShell execution commands".to_string(),
                severity: "high".to_string(),
                mitre_technique: Some("T1059.001".to_string()), // PowerShell
            });
        }

        // Check for base64 encoding (common obfuscation)
        if content_str.contains("base64") || content_str.matches(|c: char| c.is_ascii_alphanumeric() || c == '+' || c == '/').count() > file_data.len() / 2 {
            indicators.push(BehavioralIndicator {
                indicator_type: "obfuscation".to_string(),
                description: "Contains base64 encoding (possible obfuscation)".to_string(),
                severity: "medium".to_string(),
                mitre_technique: Some("T1027".to_string()), // Obfuscated Files or Information
            });
        }

        // Check for network indicators
        if content_str.contains("http://") || content_str.contains("https://") {
            indicators.push(BehavioralIndicator {
                indicator_type: "network_communication".to_string(),
                description: "Contains URLs (possible C2 communication)".to_string(),
                severity: "medium".to_string(),
                mitre_technique: Some("T1071".to_string()), // Application Layer Protocol
            });
        }

        // Check for registry manipulation
        if content_str.contains("HKEY_") || content_str.contains("RegWrite") || content_str.contains("reg add") {
            indicators.push(BehavioralIndicator {
                indicator_type: "registry_manipulation".to_string(),
                description: "Contains registry modification commands".to_string(),
                severity: "high".to_string(),
                mitre_technique: Some("T1547".to_string()), // Boot or Logon Autostart Execution
            });
        }

        // Check for credential access
        if content_str.contains("password") || content_str.contains("credential") || content_str.contains("mimikatz") {
            indicators.push(BehavioralIndicator {
                indicator_type: "credential_access".to_string(),
                description: "Contains credential-related strings".to_string(),
                severity: "critical".to_string(),
                mitre_technique: Some("T1552".to_string()), // Unsecured Credentials
            });
        }

        indicators
    }

    /// Map file behaviors to MITRE ATT&CK techniques
    async fn map_to_mitre_techniques(
        &self,
        _file_info: &FileInfo,
        behavioral_indicators: &[BehavioralIndicator],
        virustotal_result: &Option<VirusTotalResult>,
    ) -> Vec<MitreTechnique> {
        let mut techniques = Vec::new();

        // Map behavioral indicators to techniques
        for indicator in behavioral_indicators {
            if let Some(technique_id) = &indicator.mitre_technique {
                // Get technique details from NetworkSecurityAgent if available
                let (technique_name, tactic) = if let Some(_nsa) = &self.network_security_agent {
                    let mitre_kb = network_security_agent::mitre_attack::MitreAttackKB::new();
                    if let Some(tech) = mitre_kb.get_technique(technique_id) {
                        (tech.name.clone(), tech.tactic_ids.first().cloned().unwrap_or_else(|| "Unknown".to_string()))
                    } else {
                        ("Unknown".to_string(), "Unknown".to_string())
                    }
                } else {
                    ("Unknown".to_string(), "Unknown".to_string())
                };

                techniques.push(MitreTechnique {
                    technique_id: technique_id.clone(),
                    technique_name,
                    tactic,
                    confidence: 0.7,
                    evidence: indicator.description.clone(),
                });
            }
        }

        // Add techniques from VirusTotal results
        if let Some(vt) = virustotal_result {
            if vt.positives > 0 {
                // If malware detected, add initial access technique
                techniques.push(MitreTechnique {
                    technique_id: "T1566".to_string(),
                    technique_name: "Phishing".to_string(),
                    tactic: "TA0001".to_string(),
                    confidence: 0.6,
                    evidence: format!("Malicious file detected by {} vendors", vt.positives),
                });
            }
        }

        techniques
    }

    /// Assess threat level based on analysis results
    async fn assess_threat(
        &self,
        virustotal_result: &Option<VirusTotalResult>,
        mitre_techniques: &[MitreTechnique],
        behavioral_indicators: &[BehavioralIndicator],
    ) -> ThreatAssessment {
        let mut risk_score = 0.0;
        let mut is_malicious = false;
        let mut malware_families = Vec::new();

        // VirusTotal assessment
        if let Some(vt) = virustotal_result {
            let detection_ratio = vt.positives as f32 / vt.total as f32;
            risk_score += detection_ratio * 50.0;

            if vt.positives > 5 {
                is_malicious = true;
            }

            // Extract malware families from scans
            for (_engine, scan) in &vt.scans {
                if scan.detected {
                    if let Some(result) = &scan.result {
                        if !malware_families.contains(result) {
                            malware_families.push(result.clone());
                        }
                    }
                }
            }
        }

        // Behavioral indicators assessment
        let critical_count = behavioral_indicators.iter().filter(|i| i.severity == "critical").count();
        let high_count = behavioral_indicators.iter().filter(|i| i.severity == "high").count();
        let medium_count = behavioral_indicators.iter().filter(|i| i.severity == "medium").count();

        risk_score += (critical_count as f32 * 15.0) + (high_count as f32 * 10.0) + (medium_count as f32 * 5.0);

        if critical_count > 0 || high_count > 2 {
            is_malicious = true;
        }

        // MITRE techniques assessment
        risk_score += mitre_techniques.len() as f32 * 3.0;

        // Determine threat level
        let threat_level = if risk_score >= 80.0 {
            sandbox_manager::ThreatLevel::Critical
        } else if risk_score >= 60.0 {
            sandbox_manager::ThreatLevel::High
        } else if risk_score >= 40.0 {
            sandbox_manager::ThreatLevel::Medium
        } else if risk_score >= 20.0 {
            sandbox_manager::ThreatLevel::Low
        } else {
            sandbox_manager::ThreatLevel::Clean
        };

        let summary = if is_malicious {
            format!(
                "Malicious file detected with {} behavioral indicators and {} MITRE techniques",
                behavioral_indicators.len(),
                mitre_techniques.len()
            )
        } else {
            "No significant threats detected".to_string()
        };

        ThreatAssessment {
            threat_level,
            risk_score: risk_score.min(100.0),
            is_malicious,
            malware_families,
            summary,
        }
    }

    /// Generate recommendations based on threat assessment
    async fn generate_recommendations(
        &self,
        threat_assessment: &ThreatAssessment,
        mitre_techniques: &[MitreTechnique],
    ) -> Vec<String> {
        let mut recommendations = Vec::new();

        if threat_assessment.is_malicious {
            recommendations.push("âš ï¸  QUARANTINE: Isolate this file immediately and do not execute".to_string());
            recommendations.push("ðŸ” INVESTIGATE: Review system logs for signs of compromise".to_string());
            
            if !threat_assessment.malware_families.is_empty() {
                recommendations.push(format!(
                    "ðŸ¦  MALWARE FAMILIES: {}",
                    threat_assessment.malware_families.join(", ")
                ));
            }
        }

        // Add MITRE-specific recommendations
        for technique in mitre_techniques {
            match technique.technique_id.as_str() {
                "T1059.001" => recommendations.push("ðŸ›¡ï¸ MITIGATION: Restrict PowerShell execution via AppLocker or WDAC".to_string()),
                "T1027" => recommendations.push("ðŸ›¡ï¸ MITIGATION: Deploy anti-malware with deobfuscation capabilities".to_string()),
                "T1547" => recommendations.push("ðŸ›¡ï¸ MITIGATION: Monitor and restrict registry autorun keys".to_string()),
                "T1552" => recommendations.push("ðŸ›¡ï¸ MITIGATION: Implement credential guard and monitor for credential dumping".to_string()),
                _ => {}
            }
        }

        if threat_assessment.threat_level == sandbox_manager::ThreatLevel::Clean {
            recommendations.push("âœ… File appears clean, but continue monitoring for anomalous behavior".to_string());
        }

        recommendations
    }

    /// Trigger autonomous evolution cycle
    async fn trigger_evolution(&self) {
        println!("ðŸ§¬ Autonomous evolution cycle triggered");
        
        // In a full implementation, this would:
        // 1. Analyze analysis history for patterns
        // 2. Update playbooks based on success/failure rates
        // 3. Refine MITRE technique mappings
        // 4. Update behavioral indicator detection rules
        // 5. Store learned patterns in LTM
        
        let history = self.analysis_history.read().await;
        let total_analyses = history.len();
        let malicious_count = history.iter().filter(|r| r.threat_assessment.is_malicious).count();
        
        println!("  ðŸ“Š Analyzed {} files, {} malicious ({:.1}%)", 
            total_analyses, 
            malicious_count,
            (malicious_count as f32 / total_analyses as f32) * 100.0
        );
        
        // Calculate accuracy (simplified - would use ground truth in production)
        let accuracy = if total_analyses > 0 {
            // Assume VirusTotal is ground truth for now
            let correct = history.iter().filter(|r| {
                if let Some(vt) = &r.virustotal_result {
                    (vt.positives > 5) == r.threat_assessment.is_malicious
                } else {
                    false
                }
            }).count();
            correct as f32 / total_analyses as f32
        } else {
            1.0
        };
        
        println!("  ðŸŽ¯ Current accuracy: {:.1}%", accuracy * 100.0);
        
        if accuracy < self.config.accuracy_threshold {
            println!("  âš™ï¸  Accuracy below threshold, updating detection rules...");
            // Would update rules here
        }
    }

    /// Get analysis history
    pub async fn get_analysis_history(&self) -> Vec<AnalysisResult> {
        let history = self.analysis_history.read().await;
        history.clone()
    }

    /// Collaborate with NetworkSecurityAgent for network-based threat correlation
    pub async fn correlate_with_network_threats(
        &self,
        _file_hash: &str,
    ) -> Result<Vec<String>, SandboxAgentError> {
        if let Some(_nsa) = &self.network_security_agent {
            // Search for network indicators related to this file
            // This is a simplified example - full implementation would query threat intelligence feeds
            let mitre_kb = network_security_agent::mitre_attack::MitreAttackKB::new();
            let groups = mitre_kb.get_threat_groups();
            
            let mut correlations = Vec::new();
            for group in groups {
                correlations.push(format!("Threat Group: {} - {}", group.name, group.description));
            }
            
            Ok(correlations)
        } else {
            Ok(Vec::new())
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[tokio::test]
    async fn test_behavioral_analysis() {
        let config = MalwareSandboxConfig::default();
        let sandbox_config = sandbox_manager::SandboxConfig::default();
        let sandbox_manager = Arc::new(sandbox_manager::SandboxManager::new(sandbox_config).await.unwrap());
        
        let agent = MalwareSandboxAgent::awaken(sandbox_manager, config).await.unwrap();
        
        let test_data = b"powershell -enc base64encodedcommand";
        let file_info = FileInfo {
            name: "test.ps1".to_string(),
            size_bytes: test_data.len() as u64,
            sha256: "test".to_string(),
            md5: "test".to_string(),
            mime_type: None,
        };
        
        let indicators = agent.analyze_file_behavior(test_data, &file_info).await;
        assert!(!indicators.is_empty());
    }
}
