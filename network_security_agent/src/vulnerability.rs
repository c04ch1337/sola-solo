//! Vulnerability Assessment Engine
//!
//! Provides vulnerability detection, CVE lookup, and risk scoring capabilities.
//! Integrates with NVD (National Vulnerability Database) and other sources.

use crate::scanner::{HostResult, PortResult, PortState, ScanResult};
use crate::SecurityAgentError;
use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use uuid::Uuid;

/// Vulnerability assessment engine
pub struct VulnerabilityEngine {
    /// Known vulnerability database
    vuln_db: HashMap<String, VulnerabilityTemplate>,
    /// Service-to-CVE mappings
    service_vulns: HashMap<String, Vec<String>>,
}

impl VulnerabilityEngine {
    /// Create a new vulnerability engine
    pub fn new() -> Self {
        let mut engine = Self {
            vuln_db: HashMap::new(),
            service_vulns: HashMap::new(),
        };
        engine.load_vulnerability_database();
        engine
    }

    /// Load the vulnerability database
    fn load_vulnerability_database(&mut self) {
        // Common vulnerabilities by service
        self.add_vulnerability(VulnerabilityTemplate {
            id: "CVE-2021-44228".to_string(),
            name: "Log4Shell".to_string(),
            description: "Apache Log4j2 Remote Code Execution".to_string(),
            severity: Severity::Critical,
            cvss_score: 10.0,
            affected_services: vec!["java".to_string(), "tomcat".to_string(), "elasticsearch".to_string()],
            affected_ports: vec![8080, 9200, 9300],
            detection_patterns: vec!["log4j".to_string(), "jndi".to_string()],
            remediation: "Upgrade to Log4j 2.17.0 or later".to_string(),
            references: vec![
                "https://nvd.nist.gov/vuln/detail/CVE-2021-44228".to_string(),
                "https://logging.apache.org/log4j/2.x/security.html".to_string(),
            ],
            exploit_available: true,
            mitre_techniques: vec!["T1190".to_string(), "T1059".to_string()],
        });

        self.add_vulnerability(VulnerabilityTemplate {
            id: "CVE-2017-0144".to_string(),
            name: "EternalBlue".to_string(),
            description: "Windows SMB Remote Code Execution".to_string(),
            severity: Severity::Critical,
            cvss_score: 9.8,
            affected_services: vec!["microsoft-ds".to_string(), "netbios-ssn".to_string()],
            affected_ports: vec![445, 139],
            detection_patterns: vec!["smb".to_string(), "windows".to_string()],
            remediation: "Apply MS17-010 security update".to_string(),
            references: vec![
                "https://nvd.nist.gov/vuln/detail/CVE-2017-0144".to_string(),
                "https://docs.microsoft.com/en-us/security-updates/securitybulletins/2017/ms17-010".to_string(),
            ],
            exploit_available: true,
            mitre_techniques: vec!["T1210".to_string(), "T1021.002".to_string()],
        });

        self.add_vulnerability(VulnerabilityTemplate {
            id: "CVE-2019-0708".to_string(),
            name: "BlueKeep".to_string(),
            description: "Windows Remote Desktop Services RCE".to_string(),
            severity: Severity::Critical,
            cvss_score: 9.8,
            affected_services: vec!["rdp".to_string(), "ms-wbt-server".to_string()],
            affected_ports: vec![3389],
            detection_patterns: vec!["rdp".to_string(), "remote desktop".to_string()],
            remediation: "Apply Windows security updates or disable RDP".to_string(),
            references: vec![
                "https://nvd.nist.gov/vuln/detail/CVE-2019-0708".to_string(),
            ],
            exploit_available: true,
            mitre_techniques: vec!["T1210".to_string(), "T1021.001".to_string()],
        });

        self.add_vulnerability(VulnerabilityTemplate {
            id: "CVE-2014-0160".to_string(),
            name: "Heartbleed".to_string(),
            description: "OpenSSL TLS Heartbeat Extension Memory Disclosure".to_string(),
            severity: Severity::High,
            cvss_score: 7.5,
            affected_services: vec!["https".to_string(), "ssl".to_string(), "tls".to_string()],
            affected_ports: vec![443, 8443, 993, 995, 465, 587],
            detection_patterns: vec!["openssl".to_string(), "heartbeat".to_string()],
            remediation: "Upgrade OpenSSL to 1.0.1g or later".to_string(),
            references: vec![
                "https://nvd.nist.gov/vuln/detail/CVE-2014-0160".to_string(),
                "https://heartbleed.com/".to_string(),
            ],
            exploit_available: true,
            mitre_techniques: vec!["T1552".to_string()],
        });

        self.add_vulnerability(VulnerabilityTemplate {
            id: "CVE-2021-26855".to_string(),
            name: "ProxyLogon".to_string(),
            description: "Microsoft Exchange Server SSRF".to_string(),
            severity: Severity::Critical,
            cvss_score: 9.8,
            affected_services: vec!["http".to_string(), "https".to_string(), "exchange".to_string()],
            affected_ports: vec![80, 443],
            detection_patterns: vec!["exchange".to_string(), "owa".to_string(), "autodiscover".to_string()],
            remediation: "Apply Microsoft Exchange security updates".to_string(),
            references: vec![
                "https://nvd.nist.gov/vuln/detail/CVE-2021-26855".to_string(),
            ],
            exploit_available: true,
            mitre_techniques: vec!["T1190".to_string(), "T1505.003".to_string()],
        });

        self.add_vulnerability(VulnerabilityTemplate {
            id: "CVE-2020-1472".to_string(),
            name: "Zerologon".to_string(),
            description: "Netlogon Elevation of Privilege".to_string(),
            severity: Severity::Critical,
            cvss_score: 10.0,
            affected_services: vec!["ldap".to_string(), "kerberos".to_string()],
            affected_ports: vec![389, 636, 88],
            detection_patterns: vec!["domain controller".to_string(), "netlogon".to_string()],
            remediation: "Apply Windows security updates".to_string(),
            references: vec![
                "https://nvd.nist.gov/vuln/detail/CVE-2020-1472".to_string(),
            ],
            exploit_available: true,
            mitre_techniques: vec!["T1068".to_string(), "T1078".to_string()],
        });

        // SSH vulnerabilities
        self.add_vulnerability(VulnerabilityTemplate {
            id: "CVE-2018-15473".to_string(),
            name: "OpenSSH User Enumeration".to_string(),
            description: "OpenSSH through 7.7 allows username enumeration".to_string(),
            severity: Severity::Medium,
            cvss_score: 5.3,
            affected_services: vec!["ssh".to_string()],
            affected_ports: vec![22],
            detection_patterns: vec!["openssh".to_string(), "ssh-".to_string()],
            remediation: "Upgrade OpenSSH to 7.8 or later".to_string(),
            references: vec![
                "https://nvd.nist.gov/vuln/detail/CVE-2018-15473".to_string(),
            ],
            exploit_available: true,
            mitre_techniques: vec!["T1589.001".to_string()],
        });

        // MySQL vulnerabilities
        self.add_vulnerability(VulnerabilityTemplate {
            id: "CVE-2012-2122".to_string(),
            name: "MySQL Authentication Bypass".to_string(),
            description: "MySQL/MariaDB authentication bypass via timing attack".to_string(),
            severity: Severity::High,
            cvss_score: 7.5,
            affected_services: vec!["mysql".to_string(), "mariadb".to_string()],
            affected_ports: vec![3306],
            detection_patterns: vec!["mysql".to_string(), "mariadb".to_string()],
            remediation: "Upgrade MySQL/MariaDB to patched version".to_string(),
            references: vec![
                "https://nvd.nist.gov/vuln/detail/CVE-2012-2122".to_string(),
            ],
            exploit_available: true,
            mitre_techniques: vec!["T1110".to_string()],
        });

        // FTP vulnerabilities
        self.add_vulnerability(VulnerabilityTemplate {
            id: "CVE-2015-3306".to_string(),
            name: "ProFTPD mod_copy RCE".to_string(),
            description: "ProFTPD mod_copy allows remote code execution".to_string(),
            severity: Severity::Critical,
            cvss_score: 9.8,
            affected_services: vec!["ftp".to_string(), "proftpd".to_string()],
            affected_ports: vec![21],
            detection_patterns: vec!["proftpd".to_string(), "mod_copy".to_string()],
            remediation: "Disable mod_copy or upgrade ProFTPD".to_string(),
            references: vec![
                "https://nvd.nist.gov/vuln/detail/CVE-2015-3306".to_string(),
            ],
            exploit_available: true,
            mitre_techniques: vec!["T1190".to_string()],
        });

        // Web server vulnerabilities
        self.add_vulnerability(VulnerabilityTemplate {
            id: "CVE-2021-41773".to_string(),
            name: "Apache Path Traversal".to_string(),
            description: "Apache HTTP Server 2.4.49 path traversal and RCE".to_string(),
            severity: Severity::Critical,
            cvss_score: 9.8,
            affected_services: vec!["http".to_string(), "apache".to_string()],
            affected_ports: vec![80, 8080],
            detection_patterns: vec!["apache/2.4.49".to_string(), "apache/2.4.50".to_string()],
            remediation: "Upgrade Apache to 2.4.51 or later".to_string(),
            references: vec![
                "https://nvd.nist.gov/vuln/detail/CVE-2021-41773".to_string(),
            ],
            exploit_available: true,
            mitre_techniques: vec!["T1190".to_string(), "T1059".to_string()],
        });

        // Redis vulnerabilities
        self.add_vulnerability(VulnerabilityTemplate {
            id: "REDIS-UNAUTH".to_string(),
            name: "Redis Unauthenticated Access".to_string(),
            description: "Redis server accessible without authentication".to_string(),
            severity: Severity::Critical,
            cvss_score: 9.8,
            affected_services: vec!["redis".to_string()],
            affected_ports: vec![6379],
            detection_patterns: vec!["redis".to_string(), "-err".to_string()],
            remediation: "Enable Redis authentication and bind to localhost".to_string(),
            references: vec![
                "https://redis.io/topics/security".to_string(),
            ],
            exploit_available: true,
            mitre_techniques: vec!["T1190".to_string(), "T1059".to_string()],
        });

        // MongoDB vulnerabilities
        self.add_vulnerability(VulnerabilityTemplate {
            id: "MONGODB-UNAUTH".to_string(),
            name: "MongoDB Unauthenticated Access".to_string(),
            description: "MongoDB server accessible without authentication".to_string(),
            severity: Severity::Critical,
            cvss_score: 9.8,
            affected_services: vec!["mongodb".to_string()],
            affected_ports: vec![27017],
            detection_patterns: vec!["mongodb".to_string()],
            remediation: "Enable MongoDB authentication".to_string(),
            references: vec![
                "https://docs.mongodb.com/manual/security/".to_string(),
            ],
            exploit_available: true,
            mitre_techniques: vec!["T1190".to_string()],
        });

        // Telnet vulnerability
        self.add_vulnerability(VulnerabilityTemplate {
            id: "TELNET-CLEARTEXT".to_string(),
            name: "Telnet Cleartext Protocol".to_string(),
            description: "Telnet transmits credentials in cleartext".to_string(),
            severity: Severity::High,
            cvss_score: 7.5,
            affected_services: vec!["telnet".to_string()],
            affected_ports: vec![23],
            detection_patterns: vec!["telnet".to_string()],
            remediation: "Replace Telnet with SSH".to_string(),
            references: vec![],
            exploit_available: false,
            mitre_techniques: vec!["T1557".to_string(), "T1040".to_string()],
        });
    }

    /// Add a vulnerability to the database
    fn add_vulnerability(&mut self, vuln: VulnerabilityTemplate) {
        // Map services to this vulnerability
        for service in &vuln.affected_services {
            self.service_vulns
                .entry(service.clone())
                .or_default()
                .push(vuln.id.clone());
        }
        self.vuln_db.insert(vuln.id.clone(), vuln);
    }

    /// Analyze scan results for vulnerabilities
    pub async fn analyze(&self, scan_result: &ScanResult) -> Result<VulnerabilityReport, SecurityAgentError> {
        let mut vulnerabilities = Vec::new();
        let mut affected_hosts = Vec::new();

        for host in &scan_result.hosts {
            let host_vulns = self.analyze_host(host).await?;
            if !host_vulns.is_empty() {
                affected_hosts.push(host.ip.to_string());
                vulnerabilities.extend(host_vulns);
            }
        }

        // Calculate overall risk score
        let overall_risk_score = self.calculate_risk_score(&vulnerabilities);

        // Generate recommendations
        let recommendations = self.generate_recommendations(&vulnerabilities);

        Ok(VulnerabilityReport {
            id: Uuid::new_v4(),
            scan_id: scan_result.id,
            generated_at: Utc::now(),
            vulnerabilities,
            affected_hosts,
            overall_risk_score,
            recommendations,
        })
    }

    /// Analyze a single host for vulnerabilities
    async fn analyze_host(&self, host: &HostResult) -> Result<Vec<Vulnerability>, SecurityAgentError> {
        let mut vulnerabilities = Vec::new();

        for port in &host.ports {
            if port.state != PortState::Open {
                continue;
            }

            // Check by service name
            if let Some(service) = &port.service {
                if let Some(vuln_ids) = self.service_vulns.get(service) {
                    for vuln_id in vuln_ids {
                        if let Some(template) = self.vuln_db.get(vuln_id) {
                            // Check if port matches
                            if template.affected_ports.contains(&port.port) {
                                vulnerabilities.push(self.create_vulnerability(
                                    template,
                                    &host.ip.to_string(),
                                    port,
                                ));
                            }
                        }
                    }
                }
            }

            // Check by port number
            for template in self.vuln_db.values() {
                if template.affected_ports.contains(&port.port) {
                    // Check banner for detection patterns
                    if let Some(banner) = &port.banner {
                        let banner_lower = banner.to_lowercase();
                        for pattern in &template.detection_patterns {
                            if banner_lower.contains(&pattern.to_lowercase()) {
                                let vuln = self.create_vulnerability(template, &host.ip.to_string(), port);
                                if !vulnerabilities.iter().any(|v: &Vulnerability| v.cve_id == vuln.cve_id && v.host == vuln.host) {
                                    vulnerabilities.push(vuln);
                                }
                                break;
                            }
                        }
                    }
                }
            }
        }

        Ok(vulnerabilities)
    }

    /// Create a vulnerability instance from a template
    fn create_vulnerability(
        &self,
        template: &VulnerabilityTemplate,
        host: &str,
        port: &PortResult,
    ) -> Vulnerability {
        Vulnerability {
            id: Uuid::new_v4(),
            cve_id: template.id.clone(),
            name: template.name.clone(),
            description: template.description.clone(),
            severity: template.severity.clone(),
            cvss_score: template.cvss_score,
            host: host.to_string(),
            port: port.port,
            service: port.service.clone(),
            evidence: port.banner.clone().unwrap_or_default(),
            remediation: template.remediation.clone(),
            references: template.references.clone(),
            exploit_available: template.exploit_available,
            mitre_techniques: template.mitre_techniques.clone(),
            discovered_at: Utc::now(),
        }
    }

    /// Calculate overall risk score
    fn calculate_risk_score(&self, vulnerabilities: &[Vulnerability]) -> f32 {
        if vulnerabilities.is_empty() {
            return 0.0;
        }

        // Weighted average based on CVSS scores
        let total_score: f32 = vulnerabilities.iter().map(|v| v.cvss_score).sum();
        let max_score: f32 = vulnerabilities.iter().map(|v| v.cvss_score).fold(0.0, f32::max);

        // Combine average and max for overall risk
        let avg_score = total_score / vulnerabilities.len() as f32;
        (avg_score * 0.4 + max_score * 0.6).min(10.0)
    }

    /// Generate remediation recommendations
    fn generate_recommendations(&self, vulnerabilities: &[Vulnerability]) -> Vec<String> {
        let mut recommendations = Vec::new();

        // Sort by severity
        let mut sorted_vulns = vulnerabilities.to_vec();
        sorted_vulns.sort_by(|a, b| b.cvss_score.partial_cmp(&a.cvss_score).unwrap());

        // Add unique recommendations
        let mut seen = std::collections::HashSet::new();
        for vuln in sorted_vulns {
            if seen.insert(vuln.remediation.clone()) {
                recommendations.push(format!(
                    "[{}] {}: {}",
                    vuln.severity, vuln.name, vuln.remediation
                ));
            }
        }

        // Add general recommendations
        if vulnerabilities.iter().any(|v| v.severity == Severity::Critical) {
            recommendations.push(
                "URGENT: Critical vulnerabilities detected. Immediate patching required.".to_string(),
            );
        }

        if vulnerabilities.iter().any(|v| v.exploit_available) {
            recommendations.push(
                "WARNING: Exploits are publicly available for some vulnerabilities.".to_string(),
            );
        }

        recommendations
    }

    /// Lookup CVE details from NVD (placeholder for API integration)
    pub async fn lookup_cve(&self, cve_id: &str) -> Result<Option<CVEDetails>, SecurityAgentError> {
        // Check local database first
        if let Some(template) = self.vuln_db.get(cve_id) {
            return Ok(Some(CVEDetails {
                id: template.id.clone(),
                description: template.description.clone(),
                cvss_v3_score: Some(template.cvss_score),
                cvss_v3_vector: None,
                published_date: None,
                last_modified_date: None,
                references: template.references.clone(),
                cwe_ids: Vec::new(),
            }));
        }

        // In production, this would call the NVD API
        // https://services.nvd.nist.gov/rest/json/cves/2.0?cveId=CVE-XXXX-XXXXX
        Ok(None)
    }

    /// Search vulnerabilities by keyword
    pub fn search_vulnerabilities(&self, keyword: &str) -> Vec<&VulnerabilityTemplate> {
        let keyword_lower = keyword.to_lowercase();
        self.vuln_db
            .values()
            .filter(|v| {
                v.name.to_lowercase().contains(&keyword_lower)
                    || v.description.to_lowercase().contains(&keyword_lower)
                    || v.id.to_lowercase().contains(&keyword_lower)
            })
            .collect()
    }

    /// Get all known vulnerabilities in the database
    pub fn get_known_vulnerabilities(&self) -> Vec<&VulnerabilityTemplate> {
        self.vuln_db.values().collect()
    }
}

impl Default for VulnerabilityEngine {
    fn default() -> Self {
        Self::new()
    }
}

/// Vulnerability template in the database
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct VulnerabilityTemplate {
    pub id: String,
    pub name: String,
    pub description: String,
    pub severity: Severity,
    pub cvss_score: f32,
    pub affected_services: Vec<String>,
    pub affected_ports: Vec<u16>,
    pub detection_patterns: Vec<String>,
    pub remediation: String,
    pub references: Vec<String>,
    pub exploit_available: bool,
    pub mitre_techniques: Vec<String>,
}

/// Detected vulnerability
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Vulnerability {
    pub id: Uuid,
    pub cve_id: String,
    pub name: String,
    pub description: String,
    pub severity: Severity,
    pub cvss_score: f32,
    pub host: String,
    pub port: u16,
    pub service: Option<String>,
    pub evidence: String,
    pub remediation: String,
    pub references: Vec<String>,
    pub exploit_available: bool,
    pub mitre_techniques: Vec<String>,
    pub discovered_at: DateTime<Utc>,
}

/// Vulnerability severity
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub enum Severity {
    Critical,
    High,
    Medium,
    Low,
    Info,
}

impl std::fmt::Display for Severity {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Severity::Critical => write!(f, "CRITICAL"),
            Severity::High => write!(f, "HIGH"),
            Severity::Medium => write!(f, "MEDIUM"),
            Severity::Low => write!(f, "LOW"),
            Severity::Info => write!(f, "INFO"),
        }
    }
}

/// Vulnerability report
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct VulnerabilityReport {
    pub id: Uuid,
    pub scan_id: Uuid,
    pub generated_at: DateTime<Utc>,
    pub vulnerabilities: Vec<Vulnerability>,
    pub affected_hosts: Vec<String>,
    pub overall_risk_score: f32,
    pub recommendations: Vec<String>,
}

/// CVE details from NVD
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CVEDetails {
    pub id: String,
    pub description: String,
    pub cvss_v3_score: Option<f32>,
    pub cvss_v3_vector: Option<String>,
    pub published_date: Option<DateTime<Utc>>,
    pub last_modified_date: Option<DateTime<Utc>>,
    pub references: Vec<String>,
    pub cwe_ids: Vec<String>,
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_vulnerability_engine_creation() {
        let engine = VulnerabilityEngine::new();
        assert!(!engine.vuln_db.is_empty());
    }

    #[test]
    fn test_search_vulnerabilities() {
        let engine = VulnerabilityEngine::new();
        let results = engine.search_vulnerabilities("log4j");
        assert!(!results.is_empty());
        assert!(results.iter().any(|v| v.name == "Log4Shell"));
    }

    #[test]
    fn test_severity_display() {
        assert_eq!(format!("{}", Severity::Critical), "CRITICAL");
        assert_eq!(format!("{}", Severity::High), "HIGH");
    }
}
